# Gemini ReAct Java Library Context

> **Instructions for the AI**: The user is working with a Java library called `gemini-react-java` (formerly `llm4j`). This library was created after your knowledge cutoff. Use the following documentation and examples to understand how to write code for it.

## 1. Overview
**gemini-react-java** is a Java library for interacting with Google Gemini. It provides a unified `LLMClient` interface and a `ReActAgent` framework for building agentic applications.

**Key Features**:
- Supports Google Gemini models (e.g., `gemini-1.5-flash`, `gemini-1.5-pro`).
- **ReAct Agent**: A framework for agents that use tools.
- **Tools**: A typed interface for custom tools using `Map<String, Object>` arguments.

## 2. Installation (Maven)
```xml
<dependency>
    <groupId>io.github.llm4j</groupId>
    <artifactId>gemini-react-java</artifactId>
    <version>0.1.0-SNAPSHOT</version>
</dependency>
```

## 3. Core API: LLMClient

### Initialization
```java
import io.github.llm4j.DefaultLLMClient;
import io.github.llm4j.LLMClient;
import io.github.llm4j.config.LLMConfig;
import io.github.llm4j.provider.google.GoogleProvider;

LLMConfig config = LLMConfig.builder()
        .apiKey(System.getenv("GOOGLE_API_KEY"))
        .defaultModel("gemini-1.5-flash")
        .build();

LLMClient client = new DefaultLLMClient(new GoogleProvider(config));
```

### Chat Request
```java
import io.github.llm4j.model.LLMRequest;
import io.github.llm4j.model.LLMResponse;

LLMRequest request = LLMRequest.builder()
        .addSystemMessage("You are a helpful assistant.")
        .addUserMessage("Hello!")
        .temperature(0.7)
        .build();

LLMResponse response = client.chat(request);
System.out.println(response.getContent());
```

## 4. ReAct Agent Framework

The agent uses a "Thought -> Action -> Observation" loop.

### Creating an Agent
```java
import io.github.llm4j.agent.ReActAgent;
import io.github.llm4j.agent.tools.CalculatorTool;

ReActAgent agent = ReActAgent.builder()
        .llmClient(client)
        .addTool(new CalculatorTool())
        .maxIterations(10)
        .build();
```

### Running an Agent
```java
import io.github.llm4j.agent.AgentResult;

AgentResult result = agent.run("Calculate 15 * 23");
System.out.println(result.getFinalAnswer());
```

## 5. Creating Custom Tools

Tools must implement the `Tool` interface. **Crucially, the `execute` method takes a `Map<String, Object>`**.

### Interface Definition
```java
public interface Tool {
    String getName();
    String getDescription();
    // Input is a Map of arguments derived from a JSON object generated by the LLM
    String execute(Map<String, Object> args) throws Exception;
}
```

### Example: Weather Tool
```java
import io.github.llm4j.agent.Tool;
import java.util.Map;

public class WeatherTool implements Tool {
    @Override
    public String getName() { return "Weather"; }

    @Override
    public String getDescription() {
        // Be specific about the expected JSON fields
        return "Get weather for a city. Input should be a JSON object with a 'city' field.";
    }

    @Override
    public String execute(Map<String, Object> args) throws Exception {
        String city = (String) args.get("city");
        if (city == null) return "Error: Missing city";
        return "The weather in " + city + " is Sunny."; // Mock implementation
    }
}
```

## 6. Best Practices
- **Tool Descriptions**: Always specify the expected JSON structure in the `getDescription()` method (e.g., "Input should be a JSON object with 'x' and 'y' fields").
- **Error Handling**: Tools should return error strings rather than throwing unchecked exceptions, so the agent can self-correct.
- **Loop Detection**: The agent has built-in loop detection; if it gets stuck, it will receive an error observation.
